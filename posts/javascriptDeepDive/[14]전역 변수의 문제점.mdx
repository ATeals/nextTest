---
title: "[14]전역 변수의 문제점"
description: 전역 변수의 문제점에 대해 알아봅시다!
collection: 모딥다
tags: ["Javascript", "모딥다", "이론"]
date: 2023-05-16
img: "https://image.yes24.com/goods/92742567/XL"
---

> 이 글은 **모던 자바스크립트 Deep Dive**를 읽고 정리한 글입니다.

13장에서 모든 지역 스코프의 최상위 스코프는 전역 스코프라고 했던 것을 기억하시나요?

즉 전역 스코프에 선언된 전역 변수는 모든 스코프에서 참조할 수 있기 때문에 예상치 못한 오류가 발생할 수 있습니다.

# 변수의 생명주기

---

## 지역 변수의 생명주기

---

> 변수는 생물과 유사하게 생성되고 소멸되는 생명주기가 있다.
> 변수에 생명주기가 없다면 한번 선언된 변수는 프로그램을 종료하지 않는 한 영원히 메모리 공간을 점유하게 된다.

전역변수의 생명주기는 애플리케이션의 생명주기와 같습니다. 즉, 애플리케이션이 동작하는 동안에는 전역변수는 항상 존재하는 상태라는 거죠.

하지만 지역변수는 함수가 종료되면 소멸합니다.

다음 코드를 봅시다!

```jsx
function foo() {
    var x = "local";
    console.log(x); // local
    return x;
}

foo();
console.log(x); // Reference Error
```

지역 변수 **x**는 **foo**가 호출되기 전까지는 생성되지 않습니다.

> 변수 선언은 선언문이 어디에 있든 상관 없이 가장 먼저 실행된다.
> 다시 말해, 변수 선언은 코드가 한줄 씩 순차적으로 실행되는 시점인 런타임에 실행되는 것이 아니라 런타임 이전단계에서 자바스크립트 엔진에 의해 먼저 실행된다.

이는 변수 선언에 관한 내용인데요..

정확히 말하자면 전역변수에 한정된 것입니다.

지역변수의 경우에는 함수가 호출된 후 함수의 코드가 한줄씩 실행되기 이전에 자바스크립트 엔진에 의해서 먼저 실행된다고 하네요.

```jsx
function foo() {
    //변수 x가 생성된다.
    var x = "local"; // x에 local을 할당한다.
    console.log(x);
    return x;
} // x가 소멸된다.
```

함수 내부에 선언된 지역변수의 생명주기는 함수의 생명주기와 대부분 일치 하지만 지역변수가 함수보다 오래 생존하는 경우도 있습니다.

**렉시컬 환경**에서 변수가 등록된 스코프가 소멸(메모리 해제)될 때까지 변수는 유효합니다.

어느 누구도 해당 스코프를 참조하지 않는다면, **가비지 콜랙터**에 의해서 소멸합니다!

{" "}
<aside className="shadowBottom my-10 py-[20px] px-[10px] dark:bg-[#1E1E1E] bg-[#efefef] rounded-[10px]">
    📌 일반적으로 함수가 종료되면 함수가 생성한 스코프도 소멸한다. <br /> 하지만 누군가가 스코프를 참조하고 있다면 스코프는 해제되지 않고 생존하게 된다. <br /> 이는 24장 “**클로저**”에서 자세히
    살펴보자
</aside>

## 전역 변수의 생명주기

---

**var** 키워드로 선언한 전역 변수는 전역 객체에 프로퍼티가 됩니다.

예시 코드를 보죠!

```jsx
var a = 10;

console.log(window.a); // 10
```

 <aside className="shadowBottom my-10 py-[20px] px-[10px] dark:bg-[#1E1E1E] bg-[#efefef] rounded-[10px]">
📌 전역 객체?
전역 객체는 코드가  실행되기 이전 단계에 자바스크립트 엔진에 의해 어떤 객체 보다도 먼저 생성되는 특수한 객체다.
전역 객체는 클라이언트 사이드환경 에서는 **window** 서버 사이드 환경에서는 **global** 객체를 의미한다.
환경에 따라 전역 객체를 가리키는 다양한 식별자(**window**, **self**, **this**, **frames**, **global**)가 존재했으나 **ES11**에서 **globalThis**로 통일 되었다.

전역 객체는 표준 빌트인 객체(**Object**, **String**)와 환경에 따른 호스트 객체(클라이언트 **Web API**, **Node.js** 호스트 **API**), 그리고 **var**키워드로 선언한 전역 변수와 전역 함수를 프로퍼티로 갖는다.

이에 대한 자세한 내용은 21장 “빌트인 객체”에서 알아보자

</aside>

그럼 **let**, **const** 는 어떻게 될까요?

**let**과 **const**는 전역객체의 프로퍼티가 되지 않습니다.

전역에서 선언된 **let**과 **const**는 전역 블록 스코프에서 선언된 변수일 뿐이죠!

```jsx
var a = 10;
let b = 20;
const c = 30;

console.log(window.a); // 10
console.log(window.b); // undefined
console.log(window.c); // undefined
```

```jsx
let a = 10;

{
    const b = 20;
    let c = 30;

    console.log(a); // 10
    console.log(b); // 20
    console.log(c); // 30
}

console.log(a); // 10
console.log(b); // ReferenceError: b is not defined
console.log(c); // ReferenceError: c is not defined
```

2번째 예시에서 **{}**로 감싸진 **const**와 **let**은 외부에서 불러올 수 없습니다!

**const**와 **let**은 블록 스코프 내에서만 참조할 수 있기 때문이죠.

# 전역변수의 문제점

---

변수의 유효범위가 크면 클수록 코드의 가독성은 나빠지고 우리는 의도치 않게 변수의 상태를 변경하는 오류를 범할 수 있습니다.

전역 변수는 다음과 같은 문제점이 있네요

## 긴 생명주기

---

생명주기가 길다는 말은 메모리 리소스를 오랜 기간 소비한다는 말과 같습니다.
또한 상태를 변경할 수 있는 시간과 기회가 많다는 것을 의미합니다.

특히 **var**키워드는 중복선언을 허용하므로 이름이 중복될 가능성이 크네요.

### 스코프 체인 상에서 종점에 존재

이 말은 변수를 검색할 때 전역 변수가 가장 마지막에 검색된다는 것을 의미합니다.

즉, 전역변수의 검색 속도가 다른 변수에 비해 가장 느리다는 것을 말합니다.

아무리 작은 차이라도 속도 차이가 있다는 것은 좋은 의미는 아닌 거 같네요!

## 네임 스페이스 오염

---

자바스크립트의 가장 큰 문제점 중 하나는 파일이 분리되어 있다 해도 하나의 전역 스코프를 공유한다는 것입니다.

따라서 다른 파일 내에서 동일한 이름으로 명명된 전역변수나 전역 함수가 같은 스코프 내에 존재할 경우 예상치 못한 결과를 가져올 수 있습니다.

 <aside className="shadowBottom my-10 py-[20px] px-[10px] dark:bg-[#1E1E1E] bg-[#efefef] rounded-[10px]">
📌 최신 자바스크립트에서 제공하는 **module**을 이용하면 위와 같은 오류를 예방할 수 있습니다.

모듈 시스템을 사용하는 경우, **script** 태그 대신 **module** 태그를 사용하여 스크립트 파일을 로드할 수 있습니다. 모듈 시스템은 파일마다 별도의 모듈 스코프를 생성하므로, 파일 간에 전역 스코프를 공유하지 않고 독립적으로 동작할 수 있습니다.
이를 통해 충돌이나 예상치 못한 결과를 방지할 수 있습니다.

예시를 한번 볼까요?

```jsx
//moduleA.js
export let counter = 0;

//moduleB.js

import { counter } from "./moduleA.js";

counter = 10; // TypeError: Assignment to constant variable.
```

**let**은 재할당이 가능한 키워드 이지만 모듈시스템을 이용했기 때문에 **TypeError**가 발생합니다.

모듈 시스템을 사용하면 파일 간에 스코프가 분리되므로, 동일한 이름으로 선언된 전역 변수에 대한 예기치 않은 재할당이나 충돌을 방지할 수 있습니다.

</aside>

# 전역 변수의 사용을 억제하는 방법

---

변수의 스코프는 항상 좁을수록 좋습니다. 변수의 바운더리가 좁을수록 관리하기 쉽기때문이죠

## 즉시실행 함수

---

함수 정의와 동시에 호출되는 즉시실행 함수는 단 한번만 호출됩니다.

모든 코드를 즉시실행 함수로 감싸면, **var**키워드로 작성해도 함수 내부 **var**키워드 이기때문에

전역객체의 프로퍼티가 되지 않겠죠?

```jsx
(() => {
    var foo = 10; // 즉시 실행 함수의 지역변수!
})();

console.log(foo); // Reference Error
```

이 방법을 이용하면 전역 변수를 생성하지 않으므로 라이브러리 등에서 자주 사용됩니다.

(제 [모맨텀 앱 클론](https://github.com/ATeals/momentum_clone)도 각 **js**파일을 보시면 외부 파일에서 참조하지 않는 모든 코드들은 즉시실행함수 내부에 존재합니다)

## 네임 스페이스 객체

---

전역에 네임 스페이스 역할을 하는 객체를 생성하고 전역 변수처럼 사용하고 싶은 변수를 네임 스페이스 객체의 프로퍼티로 추가하는 방법입니다.

```jsx
var NAMESPACE = {};

NAMESPACE.name = "kim";

console.log(NAMESPACE.name); //kim
```

## 모듈 패턴

---

여기서 말하는 모듈패턴은 **ES6**의 모듈을 말하는 건 아닌거 같군요..

**클로저를** 이용한 방식이기 때문에

클로저 파트에서 더 다루도록 하겠습니다.

클로저는 좀 간단히 이야기 하자면 함수의 **return**에 새로운 함수를 반환해서 반환된 함수에서 이전 함수의 스코프의 값을 참조할 수 있게 하는 방법?인거 같습니다. (오래전에 공부한 내용이라 정확하지는 않지만, 클로저때 자세히 공부해봅시다!)

## ES6모듈

---

아! 책에 있었네요!

명서에 나와있는 내용을 사용합시다! **import** **export**!!

하지만 **ES6**는 **IE**를 포함한 구형 브라우저에서는 동작하지 않으며

(아직도 **IE**…? 사용하나요..? 아무튼…)

**ES6**모듈을 이용하려면 **트랜스 파일링**이나 **번들링**이 필요합니다.
