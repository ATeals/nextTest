---
title: JS의 특수 값
description: JS의 특수 값에 대해 알아봅시다!
date: 2023-05-08
collection: JS
tags: ["You Don't Know JS", "Javascript"]
img: "http://image.yes24.com/goods/43219481/XL"
---

> 이 글의 내용은 You Don’t know Js 타입과 문법, 스코프와 클로저를 읽고 정리한 문서입니다.

# 👋

안녕하세요!

오늘은
특수 값에 대해서도 알아봅시다!

# 특수값

자… 특수 값 이름부터 참 특수하네요..

저자도 특수 값은 개발자들이 사용할때 아주 조심히 다루어야 한다고 소개합니다.

(무슨 쿼카도 아니고..)

## 값이 아닌 값(!?)

**undefined** 타입의 값은 **undefined** 밖에 없습니다.

역시 `null` 또한 `null` 값만 존재합니다.

그래서 이 둘은 타입과 값이 항상 같습니다.

## Undefined

~~여러분 자바스크립트에 지정된 특정 키워드들은 변수이름으로 할당할 수 없다는 사실을 아실 겁니다.~~

~~근데 undefined는 느슨한 모드에서 값을 할당 할 수 있습니다…~~

~~(이 무슨 말도 안되네요…)~~

브라우저에서 실험해 봤는데 선언은 가능하지만 참조는 불가능 하더군요!

걱정 안 해도 될 거 같습니다.

```jsx
function a() {
    var undefined = 2;
    console.log(undefined); // 2
}
```

## void 연산자

정말 생소하네요.

`void` 연산자는 항상 결과 값을 `undefined`로 만듭니다.

기존 값은 건드리지 않으며 연산후 값은 복구할 수 없습니다.

```jsx
const a = 42;

console.log(void a, a); // undefined 42
```

하지만 `void` 연산자는 사용할 일이 거의 없습니다.

> `void` 연산자는 (어떤 표현식으로 부터) 값이 존재하는 곳에서 그 값이 `undefined`가 되어야 좋은 경우에만 사용하자. 아마도 그렇게 해야 할 경우도 거의 없고 극히 제한적으로 쓰이겠지만 제법 쓸모는 있다.

-본문 중-

>

## 특수 숫자

숫자 타입에는 몇가지 특수한 값이 있습니다. (`NaN` 이런거 보셨죠?)

### The Not number, number

수학 연산을 할때 두 피연산자가 전부 숫자가 아닐경우 유효한 숫자가 나오지 않기 때문에

결과로 `NaN`이 나옵니다.

`NaN`은 문자 그대로 `Not A Number`입니다.

> 그런데 이 명칭과 설명이 아주 형편없고 오해의 소지가 다분하다.
> `NaN`은 ‘숫자 아님’보다는 ‘유효하지 않은 숫자’, ‘실패한 숫자’, ‘몹쓸 숫자’라고 하는게 차라리 정확하다. -본문 중-

엥? 작가는 왜 이렇게 `NaN`을 말할까요?

```jsx
const a = 2 / "f0"; /// NaN

typeof a === "number"; // true
```

네? 잠깐만요..? `NaN`은 숫자가 아니라면서요?

기가 막히지 않습니까… `NaN` 의 타입은 `number` 즉, 숫자입니다….

`NaN`은 경계 값의 일종(또는 특별한 의미를 부여한 평범한 값)으로

숫자 집합 내에서 특별한 종류의 에러 상황을 나타냅니다.

그렇다면…. 어떤 변수의 값이 실패한 숫자 즉 `NaN`인지 여부를 확인할때, 코드를 어떤식으로 작성하면 좋을까요?

```jsx
const a = 2 / "f0";

a == NaN; //false
a === NaN; //false
```

네 동등 연산자(==, ===)를 사용하면…… 안 되네요…

정말 엄청난 `NaN`의 또 다른 특징은 다른 어떤 NaN과도 동등하지 않다는 점입니다.

(너무 귀하신 몸이라 자기 자신과도 다르답니다… ㅋㅋㅋㅋㅋㅋ)

따라서 `NaN` ≠ `NaN`입니다. 이상하죠?

그럼 어떤식으로 `NaN`값을 확인해야하나요?

```jsx
const a = 2 / "f0";

isNaN(a);
```

짠! `isNaN()`이라는 내장 전역 유틸리티가 있습니다! 문제 해결!

근데 `isNaN()`에는 치명적인 결함이 있습니다.

이 함수는 진짜 이름 그대로 “얘가 숫자냐?”만 판단하는 기능이 전부 입니다…

따라서 숫자가 아니지만 `NaN`도 아닌 값도 `true`를 반환하죠..

```tsx
isNaN("!!!"); // true
```

> `“!!!”`는 숫자도 아니지만 `NaN`도 아닙니다!! 이 버그는 자바스크립트 탄생 이후 오늘까지 계속되었다! -본문 중-

하지만 우리의 `ES6`부터 해결사가 등장합니다!

`Number.isNaN()` 이 친구를 이용하면 `NaN`값을 확실하게 구분할 수 있습니다.

### 무한

자바스크립트에서는 `0`으로 나눈 연산이 잘 정의 되어 있습니다. 그래서 에러가 나지 않습니다.

```tsx
1 / 0 - //Infinity
    1 / 0; //-Infinity
```

<aside>
🤢 무한대 부분에서  `IEEE754`(`IEEE**754**`는 IEEE에서 개발한 컴퓨터에서 부동 소수점을 표현하는 가장 널리 쓰이는 표준이다.)에 따른 덧셈의 연산결과에 따른 무한대 처리가 나오는데…

잘 사용할 것 같지도 않고,… ㅎㅎ 생략하겠습니다.

</aside>

### 0(영)

수학적 마인드가 풍부한 이과라면 미쳐버릴 만한 값이 있습니다.

바로! `-0`과 `+0`입니다! (네 맞아요. 음의 영 잘보고 계신 겁니다.)

```jsx
const a = 0 / -3; // -0
const b = 0 * -3; // -0
```

> 개발자 콘솔 창에서 확인하면 `-0`으로 나오겠지만,
> 비교적 최근까지도 자주 나오는 연산은 아니어서 아직도 `0`으로 표시되는 브라우저도 간혹 있다. -본문 중-

명세서의 의하면 `-0`의 문자열화는 항상 `“0”`입니다.

```jsx
const a = 0 / -3;

String(a); // "0"
JSON.stringify(a); // "0"

Number("-0"); // -0
```

그치만 반대로 하면 `-0`으로 잘나온답니다.

> 그런데 무슨 수학 경시 대회도 아니고 `-0`은 왜 만든 것일까?

값의 크기로 어떤 정보(ex: 애니메이션 프레임당 넘김 속도)와 그 값의 부호로 또다른 정보(ex: 넘김 방향)를 동시에 나타내야하는 어플리케이션이 있기 때문이다.

`+0 -0`이 없다면 어떤 변수 값이 0에 도달하는 순간 부호가 소실되어 이동방향을 알 수가 없으므로 `+0`와 -0은 유용하다!

-본문 중-

>

즉 웹 프로그래밍을 하면서 모든 숫자를 백터값으로 나타내는 것이 유용 하다고 생각한 것 같습니다…

### 특이한 동등비교

앞서 본 것과 같이 동등비교가 특이한 친구들이 있습니다.

-   `NaN`은 자기 자신과도 동등하지 않다.
-   `-0`은 거짓말쟁이라서 `0`과 동등한 척 하는 경우가 있다.

ES6부터는 잡다한 예외를 걱정하지 않고 두 값이 절대적으로 동등한지 확인하는 유틸리티가 있습니다.

바로 `Object.is()`!

```jsx
const a = 2 / "f";

Object.is(a, NaN); // true
```

# 값 vs 래퍼런스

본문에서 설명하기를 `c++`와 같은 포인터를 이용한 언어와 자바스크립트를 비교합니다…

하지만 너무 어렵고, 공부해야하는 점이 기하 급수적으로 늘어나니까 예시를 한번 보죠…

```jsx
var a = 2;
var b = a; // b는 언제나 a에서 값을 복사합니다.

b++;
console.log(a, b); // 2, 3

var c = [1, 2, 3];
var d = c; // d는 공용된 [1,2,3]값의 레퍼런스다.
d.push(4);
c; // [1,2,3,4]
d; // [1,2,3,4]
```

`null`, `undefined`, `string`, `number`, `boolean` 그리고 `symbol`과 같은 단순한 값(스칼라 원시값)은

언제나 값-복사 방식으로 할당/전달 됩니다.

객체나 함수등 합성 값은 할당/전달시 반드시 레퍼런스 사본을 생성합니다.

> 예제에서 `2`는 스칼라 원시 값이므로 `a`엔 이 값의 초기 사본이 들어가고, `b`에는 또 다른 사본이 자리를 잡는다. 따라서 `b`를 바꿈으로써 `a`까지 동시에 값을 변경할 방법은 없다.

하지만 `c`와 `d`는 모두 합성 값이자 동일한 공유 값 `[1,2,3]`에 대한 개별 레퍼런스다. 여기서 기억해야 할 점은 `c`와 `d`가 `[1,2,3]`을 “소유”하는 것이 아니라 단지 이 값을 동등하게”참조”만 한다는 사실이다.
따라서 레퍼런스로 실제 공유한 배열 값이 변경되면(`push()`), 이 공유 값 한 곳에 영향을 미치므로
두 래퍼런스는 갱신된 값을 동시에 참조한다.

-본문 중-

>

후… 정말 어렵네요… 좀만 쉽게 말해보자면,

-   단순 값을 할당할 때는 값을 복사하는 방식으로 변수 할당, 전달,
    따라서 `b= a`로 복사해도 값이 복사됨! `(a = 1, b = 1)`
    변경시 각각 변경됨.
-   합성값은 레퍼런스 즉 참조로 변수 할당, 전달,
    따라서 `c = d`라고 하면 `c`가 가리키는 `[1,2,3]`을 동시에 `d`도 가리킴! `(c → [1,2,3] ← d)`
    변경시 참조하고 있는 합성 값이 수정 됨으로 동시에 변경됨

그렇다고 오해하면 안되는게 레퍼런스는 변수가 아닌 값 자체를 가리키므로 다른 `a` 레퍼런스로 `b`레퍼런스가 가리키는 대상을 변경할 수는 없습니다.

```jsx
const a = [1, 2, 3];
const b = a;
a; // [1,2,3]
b; // [1,2,3]

b = [4, 5, 6];
a; // [1,2,3]
b; // [4,5,6]
```

## 함수 인자에서의 레퍼런스

```jsx
function arr(x) {
    x.push(4);
    x; // [1,2,3,4]

    x = [4, 5, 6];
    x.push(7);
    x; // [4,5,6,7]
}

const a = [1, 2, 3];
arr(a);
a; // [1,2,3,4]
```

이는 위에서 설명한 상황과 동일합니다.

함수의 매개변수 `x`와 `a`가 둘다 `[1,2,3]`을 참조하고 `push()`는 참조 값을 바꾸므로 `[1,2,3,4]`가 되고,

`x`의 참조를 `[4,5,6]`으로 수정해도 `a`는 수정되지 않습니다. (자바스크립트에는 포인터가 없으니까!)

```jsx
function arr(x) {
    x.push(4);
    x; // [1,2,3,4]

    x.length = 0; // 배열을 초기화합니다!
    x.push(4, 5, 6, 7);
    x; // [4,5,6,7]
}

const a = [1, 2, 3];
arr(a);
a; // [4,5,6,7]
```

보시면 짐작할 수 있듯 `x.length = 0` 과 `x.push(4,5,6,7)`은 새 배열을 만드는 코드가 아닌, `a`와 `x`가 공유한 배열을 변경하는 코드이므로 `a`의 값도 바뀌게 됩니다.

정말 어렵네요….

값을 복사하냐 레퍼런스를 복사하냐는 우리가 마음대로 결정할 수 있는 사실이 아닙니다…

값의 타입을 보고 엔진이 결정하는 사항이빈다…

그래서 합성값(배열, 객체..)을 효과적으로 값-복사 하려면, 각 합성값의 사본을 만들어 전달하는 메서드나 방법을 이용합니다.

```tsx
func(a.slice());
```

`slice()`는 사본을 전달합니다. 그렇다면 `func`의 메개변수는 `a`의 사본을 가리키게 되니 `a`를 건드릴 수 없겠죠?

반대로 단순값을 래퍼런스-복사 하려면 원시 값을 다른 합성값으로 감싸는 방법이 있습니다.

(이건 나중에 boxing파트에서 하는 걸로 합시다…)

# 🧹정리하기

-   `null`타입은 `null`값 하나이고 `undefined` 타입도 `undefined`하나입니다.
-   `undefined`는 할당된 값이 없다면 모든 변수/프로퍼티의 디폴트 값입니다.
-   숫자에는 `NaN`(숫자 아님인데…. 숫자인…), `Infinity`(+,-), `-0`같은 특수 값이 있습니다.
-   단순 값은 값-복사에 의해, 합성 값은 레퍼런스-복사에 의해 값이 할당/전달 됩니다.
    자바스크립트의 레퍼런스는 다른 언어의 레퍼런스/포인터와는 전혀 다른 개념이므로,
    또다른 변수/레퍼런스가 아닌 오직 자신의 값만을 가리킵니다.

오늘은 자바스크립트 특수값에 대해 알아봤는데…

다시 봐도 어렵네요…..

추가적으로 공부하고 싶으시면 책을 한번 읽어보시거나 다른 문헌을 참고 하는편이 좋을 것같습니다.

특히 레퍼런스 개념은 이해하고 있다면 `react`를 이용할 때 오류를 찾아내기 쉬울 거 같습니다..

다음에는 “네이티브”라고 불리우는 여러 가지 내장 타입을 만나보겠습니다.

걱정마세요! (`Number()`)이런 친구입니다.

그럼….
